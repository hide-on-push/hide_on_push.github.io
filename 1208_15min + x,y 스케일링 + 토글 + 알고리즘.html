<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 15min live </title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* 기본 버튼 스타일 */
        .text {
            display: block;
        }
        .button {
            display: inline-block;
            stroke: none; /* 기본 윤곽선 없음 */
            cursor: pointer; /* 마우스를 올리면 포인터 표시 */
            transition: stroke 0.3s ease; /* 윤곽선 애니메이션 */
            
        }

        /* 마우스를 올렸을 때 윤곽선 추가 */
        .button:hover {
            stroke: #040604b4; /* 윤곽선 색상 */
            stroke-width: 2px; /* 윤곽선 두께 */
        }

        .eye-icon {
            fill: none;
            stroke: grey;
            stroke-width: 2;
            display: none;
        }

        .eye-icon.circle {
            fill : grey;
            opacity: 0.8;
        }

        .button:hover .eye-icon {
            display: block;
        }
        @import url('https://fonts.googleapis.com/css2?family=Boogaloo&display=swap');

body {
    font-family: 'Boogaloo', sans-serif;
    font-weight: 700;
}


        .highlight {
            animation: blink 1s infinite alternate;
        }

        @keyframes blink {
            0% { fill: rgba(0, 255, 0, 0.2); }
            100% { fill: rgba(0, 255, 0, 0.6); }
        }
    </style>
    
</head>
<body>
    <script>
        const buttonWidth = 1400;
        const buttonHeight = 50;
        const width = window.innerWidth;
        const height = window.innerHeight-10;
        const marginTop = 20;
        const marginRight = 75; // 50에서 75으로 수정 
        const marginBottom = 30;
        const marginLeft = 10; //50에서 10으로 수정

        // 영역 비율에 따른 스케일 정의
        const x = d3.scaleBand().range([marginLeft, width - marginRight]).padding(0.3);
        const xBar = d3.scaleBand().range([marginLeft, width - marginRight]).padding(0.1);

        const y1 = d3.scaleLinear().range([height * 0.5, marginTop]); // 캔들스틱: 상단 50%
        const y2 = d3.scaleLinear().range([height * 0.625, height * 0.5 + 5]); // Volume: 50% ~ 62.5%
        const yRSI = d3.scaleLinear().range([height * 0.75, height * 0.625 + 5]); // RSI: 62.5% ~ 75%
        const yMACD = d3.scaleLinear().range([height * 0.875, height * 0.75 + 5]); // MACD: 75% ~ 87.5%
        const ystochastic = d3.scaleLinear().range([height - marginBottom, height * 0.875 + 5]); // Stochastic: 87.5% ~ 100%

        const svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height);
        
        //ㅇㅇ
        

        let ticker = [];
        let ticker_for_indicator = [];

        const buttonMA7 = createButton(marginLeft, 0, "ma-line-7");
        const buttonTextMA7 = buttonMA7.append("text")
            .attr("class", "button text")
            .attr("y", buttonHeight / 4)
            .attr("dy", "0.35em") // Center vertically
            .attr("text-anchor", "start") // Center horizontally
            .style("font-family", "Arial, sans-serif")
            .style("font-size", "14px")
            .style("fill", "black")
            .text("MA7");

        const buttonMA25 = createButton(marginLeft, height*0.035, "ma-line-25");
        const buttonTextMA25 = buttonMA25.append("text")
            .attr("class", "button text")
            .attr("y", buttonHeight / 4)
            .attr("dy", "0.35em") // Center vertically
            .attr("text-anchor", "start") // Center horizontally
            .style("font-family", "Arial, sans-serif")
            .style("font-size", "14px")
            .style("fill", "black")
            .text("MA25");

        const buttonMA99 = createButton(marginLeft, height*0.07, "ma-line-99");
        const buttonTextMA99 = buttonMA99.append("text")
            .attr("class", "button text")
            .attr("y", buttonHeight / 4)
            .attr("dy", "0.35em") // Center vertically
            .attr("text-anchor", "start") // Center horizontally
            .style("font-family", "Arial, sans-serif")
            .style("font-size", "14px")
            .style("fill", "black")
            .text("MA99");

        const buttonvolume = createButton(marginLeft, height*0.5, "volume-bars");
        const buttonTextvolume = buttonvolume.append("text")
            .attr("class", "button text")
            .attr("y", buttonHeight / 4)
            .attr("dy", "0.35em") // Center vertically
            .attr("text-anchor", "start") // Center horizontally
            .style("font-family", "Arial, sans-serif")
            .style("font-size", "14px")
            .style("fill", "black")
            .text("volume");
            
        const buttonRSI = createButton(marginLeft, height*0.625, "rsi");
        const buttonTextRSI = buttonRSI.append("text")
            .attr("class", "button text")
            .attr("y", buttonHeight / 4)
            .attr("dy", "0.35em") // Center vertically
            .attr("text-anchor", "start") // Center horizontally
            .style("font-family", "Arial, sans-serif")
            .style("font-size", "14px")
            .style("fill", "black")
            .text("RSI");

        const buttonMACD = createButton(marginLeft, height*0.75, "MACD");
        const buttonTextMACD = buttonMACD.append("text")
            .attr("class", "button text")
            .attr("y", buttonHeight / 4)
            .attr("dy", "0.35em") // Center vertically
            .attr("text-anchor", "start") // Center horizontally
            .style("font-family", "Arial, sans-serif")
            .style("font-size", "14px")
            .style("fill", "black")
            .text("MACD");

        const buttonstochastic = createButton(marginLeft, height*0.875, "stochastic");
        const buttonTextstochastic = buttonstochastic.append("text")
            .attr("class", "button text")
            .attr("y", buttonHeight / 4)
            .attr("dy", "0.35em") // Center vertically
            .attr("text-anchor", "start") // Center horizontally
            .style("font-family", "Arial, sans-serif")
            .style("font-size", "14px")
            .style("fill", "black")
            .text("Stochastic");
        
            const buttonbollingararea = createButton(marginLeft, height*0.105, "bollinger-area");
            const buttonTextbollingararea = buttonbollingararea.append("text")
            .attr("class", "button text")
            .attr("y", buttonHeight / 4)
            .attr("dy", "0.35em") // Center vertically
            .attr("text-anchor", "start") // Center horizontally
            .style("font-family", "Arial, sans-serif")
            .style("font-size", "14px")
            .style("fill", "black")
            .text("bollingar area");



        // Initial data load from API
        async function fetchInitialData() {
            const response = await fetch("https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=15m&limit=1020");
            const data = await response.json();
            data.pop();

            ticker = data.map(d => ({
                Date: new Date(d[0]), //csv와 달리 키 이름이 제공되는것이 아니기 때문에 
                Open: +d[1],
                High: +d[2],
                Low: +d[3],
                Close: +d[4],
                Volume: +d[5]
            }));

            ticker_for_indicator = ticker;

            ticker = ticker.slice(-980);

            calculateMACD();
            calculateMA();
            calculateRSI();
            calculatestochastic();
            calculateBollingerBands();

            UpdateScales();
            initializeChart();
            updateChart();
            startWebSocket();
        }

        function UpdateScales() {
            x.domain(ticker.map(d => d.Date));
            xBar.domain(ticker.map(d => d.Date));

            const visibleData = ticker.filter(d => x(d.Date) >= 0 && x(d.Date) <= width);
                //0->marginLeft

            // 전체 데이터와 보이는 데이터의 Low와 High를 비교하여 y1 도메인 설정. 즉, 전체 데이터 중 최소와 최대 값
            const globalLow = Math.min(
                d3.min(ticker, d => d.Low), 
                d3.min(ticker, d => d.lowerband)
            );

            const globalHigh = Math.max(
                d3.max(ticker, d => d.High), 
                d3.max(ticker, d => d.upperband)
            );

            // visibleData의 Low와 High 계산. 즉, 보이는 데이터 중 최소와 최대 값
            const visibleLow = visibleData.length > 0 
                ? Math.min(
                    d3.min(visibleData, d => d.Low), 
                    d3.min(visibleData, d => d.lowerband)
                ) 
                : globalLow;

            const visibleHigh = visibleData.length > 0 
                ? Math.max(
                    d3.max(visibleData, d => d.High), 
                    d3.max(visibleData, d => d.upperband)
                ) 
                : globalHigh;
            // y1 도메인을 전체와 visibleData를 비교하여 설정
            y1.domain([
                Math.max(globalLow, visibleLow), // Low는 더 큰 값을 선택
                Math.min(globalHigh, visibleHigh) // High는 더 큰 값을 선택
            ]).nice();
            


            y2.domain([0, d3.max(ticker, d => d.Volume)]);
            yMACD.domain([
                Math.floor(Math.min(
                    d3.min(ticker, d => d.macd_line),
                    d3.min(ticker, d => d.signal_line),
                    d3.min(ticker, d => d.histogram))/200) * 200,
                Math.ceil(Math.max(
                    d3.max(ticker, d => d.macd_line),
                    d3.max(ticker, d => d.signal_line),
                    d3.max(ticker, d => d.histogram))/200) * 200
            ]); //MACD 도 50단위로 끊음으로써 자체적인 Margin 부여.
            yRSI.domain([-9.25, 106.5]);
            ystochastic.domain([-9.25,106.5]);
        }

        function initializeChart() {
            //clippath 정의    
            svg.append("defs")
                .append("clipPath")
                .attr("id", "chart-clip")
                .append("rect")
                .attr("x", marginLeft )
                .attr("y", marginTop)
                .attr("width", width - marginLeft - marginRight)
                .attr("height", height - marginTop );
            //clippath 경로
            svg.append("g")
                .attr("clip-path", "url(#chart-clip)")
                .attr("class", "chart-content");


            // x축에 시간
            svg.append("g")
                .attr("transform", `translate(0,${height - marginBottom})`)
                .call(d3.axisBottom(x) // svg에 d3객체 추가. 즉, 우리가 설정한 x값을 svg에 추가함.
                    .tickFormat(d3.timeFormat("%H:%M")) // 시:분의 형식으로 출력
                    .tickValues(d3.utcHour // x축의 간격을 설정 월요일에 해당하는 날짜만 표시
                        .every(3)
                        .range(ticker.at(0).Date, +ticker.at(-1).Date + 1) //데이터 시작 날짜부터 끝 날짜까지 x축 레이블 표시.
                    )
                )
                .attr("class","x-time");    
                

            
            //일단은 격자선 다 제거하고, updatescale에서 추가.
            svg.append("g")
                .attr("transform", `translate(${width-marginRight},0)`) //모든 marginleft 이걸로 수정.
                .call(d3.axisRight(y1).tickFormat(d3.format("$~f")))//모든 axisleft->axisright로 수정
                .attr("class","y-candle");

            svg.append("g")
                .attr("transform", `translate(${width-marginRight},0)`)
                .call(d3.axisRight(y2).tickFormat(d => `${d}`))
                .attr("class", "y-volume");
                
            //MACD 격자선
            svg.append("g")
                .attr("transform", `translate(${width-marginRight},0)`)
                .call(d3.axisRight(yMACD)        
                .tickValues(d3.range(Math.floor(yMACD.domain()[0] / 200) * 200, Math.ceil(yMACD.domain()[1] / 200) * 200 + 1, 200 ))) // 50단위 표시
                .attr("class","y-MACD");

            //RSI 격자선
            svg.append("g")
                .attr("transform", `translate(${width-marginRight},0)`)
                .call(d3.axisRight(yRSI)
                    .tickValues(d3.range(0, 101, 20))) // 20단위로 표시
                .attr("class","y-RSI");
                

            //ystochastic 격자선
            svg.append("g")
                .attr("transform", `translate(${width-marginRight},0)`)
                .call(d3.axisRight(ystochastic)
                    .tickValues(d3.range(0, 101, 20))) // 20 단위 표시
                .attr("class","y-stochastic");

            // candlestick class
            svg. append("g").attr("class", "candlesticks");
            
            // volume bar class
            svg.append("g").attr("class","volume-bars");

            // MA class
            svg.append("g").attr("class", "ma-lines");

            // MACD class
            svg.append("g").attr("class","MACD");

            // RSI class
            svg.append("g").attr("class", "RSI");
            
            // y-stochastic clas
            svg.append("g").attr("class", "stochastic");

            svg.append("g").attr("class","bollinger-area");

            svg.append("g").attr("class","bollinger-lines");

            // 이 밑의 코드는 왜 필요한거..? chart-content class도 마찬가지.
            const chartContent = svg.select(".chart-content");
            
            // 캔들스틱 그룹
            chartContent.append("g").attr("class", "candlesticks");

            // 거래량 바 그룹
            chartContent.append("g").attr("class", "volume-bars");

            // MA 라인
            chartContent.append("g").attr("class", "ma-lines");

            // MACD, RSI, Stochastic, Bollinger Bands
            chartContent.append("g").attr("class", "MACD");
            chartContent.append("g").attr("class", "RSI");
            chartContent.append("g").attr("class", "stochastic");
            chartContent.append("g").attr("class", "bollinger-area");
            chartContent.append("g").attr("class", "signal-text");
            chartContent.append("g").attr("class", "divergence");
            chartContent.append("g").attr("class", "highlight");
            chartContent.append("g").attr("class", "bollinger-lines");

        }

        const tickInterval = zoomLevel => {
                if (zoomLevel >= 5) return 5; // 줌 레벨이 크면 1분 간격
                if (zoomLevel >= 2) return 10; // 중간 줌 레벨이면 5분 간격
                return 30; // 줌 레벨이 작으면 15분 간격
            };


        function updateChart(zoomLevel){
            UpdateScales();

            const interval = tickInterval(zoomLevel); // 줌 레벨에 따른 간격 계산

            // x축 업데이트
            svg.select(".x-time")
                .call(d3.axisBottom(x) // svg에 d3객체 추가. 즉, 우리가 설정한 x값을 svg에 추가함.
                    .tickFormat(d3.timeFormat("%H:%M")) // 시:분의 형식으로 출력
                    .tickValues(
                        d3.utcHour // x축의 간격을 설정 월요일에 해당하는 날짜만 표시
                        .every(interval)
                        .range(ticker.at(0).Date, +ticker.at(-1).Date + 1) //데이터 시작 날짜부터 끝 날짜까지 x축 레이블 표시.
                    )
                    
                )
                .call(g => g.select(".domain").remove()) // x축의 기본선 선택 후 제거
                .call(g => {// 삐져나오는 x축 레이블 제거
                    g.selectAll(".tick").each(function(d) {
                        const posX = x(d);// tick의 x좌표 계산

                        if (posX < marginLeft || posX > width - marginRight) { 
                        d3.select(this).select("line").style("display", "none"); // 선 숨기기
                        d3.select(this).select("text").style("display", "none"); // 레이블 숨기기
                    } else {
                        d3.select(this).select("line").style("display", null); // 선 복구
                        d3.select(this).select("text").style("display", null); // 레이블 복구
                    }
                    });
                });

            // y축 업데이트하면서 격자선 추가하는 시스템으로 변경
            svg.select(".y-candle")
                .call(d3.axisRight(y1)
                    .tickFormat(d3.format("$~f"))
                    .tickSize(-(width - marginLeft - marginRight)))
                .call(g => {
                    
                    g.selectAll(".tick line")
                        .attr("stroke-opacity", 0.2); // 투명도 설정
                });

            svg.select(".y-volume")
                .call(d3.axisRight(y2)
                    .tickFormat(d => `${d}`)
                    .tickSize(-(width - marginLeft - marginRight)))
                .call(g => {
                    
                    g.selectAll(".tick line")
                        .attr("stroke-opacity",0.2);
                })

            svg.select(".y-MACD")
                .call(d3.axisRight(yMACD)        
                    .tickValues(d3.range(Math.floor(yMACD.domain()[0] / 200) * 200, Math.ceil(yMACD.domain()[1] / 200) * 200 + 1, 200 ))
                    .tickSize(-(width - marginLeft - marginRight)))
                .call(g => {
                   
                    g.selectAll(".tick line")
                        .attr("stroke-opacity", 0.2); 
                });
                    
            svg.select(".y-RSI")
                .call(d3.axisRight(yRSI)
                    .tickValues(d3.range(0, 101, 20))
                    .tickSize(-(width - marginLeft - marginRight)))
                .call(g => {
                    
                    g.selectAll(".tick line")
                        .attr("stroke-opacity", 0.2); 
                });

            svg.select(".y-stochastic")
                .call(d3.axisRight(ystochastic)
                    .tickValues(d3.range(0, 101, 20))
                    .tickSize(-(width - marginLeft - marginRight)))
                .call(g => {
                    
                    g.selectAll(".tick line")
                        .attr("stroke-opacity", 0.2); 
                });

            
   
             // 캔들스틱 업데이트
             const candlesticks = svg.select(".candlesticks")
                .selectAll("g")
                .data(ticker, d=>d.date);

            // Enter: 새로운 데이터에 대해 g 그룹 생성
            const candlesticksEnter = candlesticks.enter()
                .append("g")
                .attr("transform", d => `translate(${x(d.Date)+ x.bandwidth() / 2}, ${y1(d.Low)})`);

            candlesticksEnter.append("line") // 고가-저가 라인
                .attr("class", "high-low-line")
                .attr("y1", 0)  //기존의 코드와 enter하면서 transform을 했기 때문에 기존과 달리 상대 좌표계를 써야함.
                .attr("y2", d => y1(d.High) - y1(d.Low)) // 그룹 좌표계의 기준점(저가)에서 시작 -> 저가에서 고가까지의 높이
                .attr("stroke", "black");

            candlesticksEnter.append("line") // 시가-종가 라인
                .attr("class", "open-close-line")
                .attr("y1", d => y1(d.Open) - y1(d.Low)) //저가를 기준으로 한 시가의 상대적 높이
                .attr("y2", d => y1(d.Close) - y1(d.Low)) //저가를 기준으로 종가의 상대적 높이
                .attr("stroke-width", x.bandwidth())
                .attr("stroke", d => d.Open > d.Close ? "rgb(227,84,97)" : "rgb(94,186,137)");

            // Update: 기존 데이터에 추가
            candlesticks
                .merge(candlesticksEnter) // Enter된 데이터와 기존 Update를 병합
                .attr("transform", d => `translate(${x(d.Date)+ x.bandwidth() / 2}, ${y1(d.Low)})`)
                .select(".high-low-line") // 고가-저가 라인 업데이트
                .attr("y2", d => y1(d.High) - y1(d.Low));

            candlesticks
                .merge(candlesticksEnter) // 시가-종가 라인 업데이트
                .select(".open-close-line")
                .attr("y1", d => y1(d.Open) - y1(d.Low))
                .attr("y2", d => y1(d.Close) - y1(d.Low))
                .attr("stroke", d => d.Open > d.Close ? "rgb(227,84,97)" : "rgb(94,186,137)");

            // Exit: 첫 element 제거
            candlesticks.exit().remove();

            // 거래량 바 업데이트
            const volumeBars = svg.select(".volume-bars")
                .selectAll("rect")
                .data(ticker, d => d.Date);//??
                

            const volumeBarsEnter = volumeBars.enter()
                .append("rect")
                .attr("x", d => x(d.date))
                .attr("y", d => y2(d.Volume))
                .attr("height", d => y2(0) - y2(d.Volume))
                .attr("width", xBar.bandwidth())
                .attr("fill", d => d.Open > d.Close ? "rgb(227,84,97)" : "rgb(94,186,137)")
                .attr("opacity", 0.6);

            volumeBarsEnter.merge(volumeBars)
                .attr("x", d => x(d.Date))
                .attr("y", d => y2(d.Volume))
                .attr("height", d => y2(0) - y2(d.Volume))
                .attr("width", xBar.bandwidth())
                .attr("fill", d => d.Open > d.Close ? "rgb(227,84,97)" : "rgb(94,186,137)");

            volumeBars.exit().remove();

            // MA 라인 업데이트
            let average7 = getMovingAverageData(ticker_for_indicator, 7);
            let average25 = getMovingAverageData(ticker_for_indicator, 25);
            let average99 = getMovingAverageData(ticker_for_indicator, 99);
            
            average7 = average7.slice(-980);
            average25 = average25.slice(-980);          
            average99 = average99.slice(-980);

            const maLines = [
                { data: average7, color: "orange", className: "ma-line-7" },
                { data: average25, color: "hotpink", className: "ma-line-25" },
                { data: average99, color: "cyan", className: "ma-line-99" }
            ];

            maLines.forEach(({ data, color, className }) => {

                const line = svg.select(".ma-lines")
                    .selectAll(`.${className}`)
                    .data([data], d => d.Date);

                const lineEnter = line.enter()
                    .append("path")
                    .attr("class", className)
                    .attr("fill", "none")
                    .attr("stroke", color)
                    .attr("stroke-width", 1.5)
                    .attr("d", d3.line()
                        .x(d => x(d.Date) + x.bandwidth() / 2)
                        .y(d => y1(d.average))
                    );

                lineEnter.merge(line)
                    .attr("d", d3.line()
                        .x(d => x(d.Date) + x.bandwidth() / 2)
                        .y(d => y1(d.average))
                    );

                line.exit().remove();
            });


            // MACD
            const MacdLines = svg.select(".MACD")
                .selectAll
            const macdLine = d3.line()
                .x(d => x(d.Date) + x.bandwidth() / 2)
                .y(d => yMACD(d.macd_line));

            const signalLine = d3.line()
                .x(d => x(d.Date) + x.bandwidth() / 2)
                .y(d => yMACD(d.signal_line));

            const MACD_Lines = [
                {color: "blue", className: "macdline" , Scale: macdLine},
                {color: "red", className: "signalline", Scale: signalLine}
            ];

            MACD_Lines.forEach(({ color, className, Scale }) => {
                const line = svg.select(".MACD")
                    .selectAll(`.${className}`)
                    .data([ticker], d => d.Date);
                
                    line.enter()
                        .append("path")
                        .attr("class", className)
                        .attr("fill", "none")
                        .attr("stroke", color)
                        .attr("stroke-width", 1.5)
                        .merge(line) // Enter한 데이터 기존 데이터와 병합하여 Update
                        .attr("d", Scale);

                    line.exit().remove();

                line
                    .attr("d", Scale);
            });
            
            
            // MACD Histogram
            const MACD_Histogram = svg.select(".MACD")
                .selectAll("rect")
                .data(ticker, d => d.Date);

            MACD_Histogram.enter()
                .append("rect")
                .attr("x", d => x(d.Date))
                .attr("y", d => d.histogram >= 0 ? yMACD(d.histogram) : yMACD(0))
                .attr("height", d => Math.abs(yMACD(d.histogram)-yMACD(0)))
                .attr("width", xBar.bandwidth())
                .attr("fill", d => d.histogram >= 0 ? "rgb(227,84,97)" : "rgb(94,186,137)")
                .attr("opacity", 0.6);

            MACD_Histogram.exit().remove();

            MACD_Histogram
                .attr("x", d => x(d.Date))
                .attr("y", d => d.histogram >= 0 ? yMACD(d.histogram) : yMACD(0))
                .attr("height", d => Math.abs(yMACD(d.histogram)-yMACD(0)))
                .attr("width", xBar.bandwidth());


            // // RSI Line
            // const rsiLine = d3.line()
            //     .x(d => x(d.Date) + x.bandwidth() / 2)
            //     .y(d => yRSI(d.Rsi));

            // // RSI 
            // const RSI_lines = svg.select(".RSI")
            //     .selectAll(".rsiLine")
            //     .data([ticker.filter(d => d.Rsi !== null)]);

            // RSI_lines.enter()
            //     .append("path")
            //     .attr("class", "rsiLine")
            //     .attr("fill", "none")
            //     .attr("stroke", "green")
            //     .merge(RSI_lines) // Enter한 데이터 기존 데이터와 병합하여 Update
            //     .attr("d", rsiLine);

            // RSI_lines.exit().remove();

            // RSI chart
            const rsiData_2 = calculateRSI_2(ticker, 14);
            const pivotLows = findPivotLows(rsiData_2, 5);
            const divergences = calculateDivergences(ticker, pivotLows);

            // chartContent 내부의 .RSI 그룹 선택
            const chartContent = svg.select(".chart-content");
            const rsiGroup = chartContent.select(".RSI");

            // 기존 RSI 그룹 내용 제거
            rsiGroup.selectAll("*").remove();

            // RSI 축을 chart-content 바깥에서 그릴지, 안에서 그릴지 결정
            // 보통 축은 clipping하지 않으므로 아래와 같이 svg 바로 밑에 남겨두거나
            // 필요하다면 chartContent 밖에 새 그룹을 append해서 그린다.
            svg.selectAll(".rsi-axis").remove();
            const rsiAxis = svg.append("g")
                .attr("class", "rsi-axis")
                .attr("transform", `translate(0,${height*0.75})`)
                .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%H:%M"))                    
                    .tickValues(
                        d3.utcHour.every(interval)
                        .range(ticker.at(0).Date, +ticker.at(-1).Date + 1)
                    )
                )
                .call(g => g.select(".domain").remove()) // x축의 기본선 선택 후 제거
                .call(g => {// 삐져나오는 x축 레이블 제거
                    g.selectAll(".tick").each(function(d) {
                        const posX = x(d);// tick의 x좌표 계산

                        if (posX < marginLeft || posX > width - marginRight) { 
                        d3.select(this).select("line").style("display", "none"); // 선 숨기기
                        d3.select(this).select("text").style("display", "none"); // 레이블 숨기기
                    } else {
                        d3.select(this).select("line").style("display", null); // 선 복구
                        d3.select(this).select("text").style("display", null); // 레이블 복구
                    }
                    });
                });

            // RSI 라인 추가 (chart-content 내부의 .RSI 그룹에 추가)
            rsiGroup.append("path")
                .datum(rsiData_2)
                .attr("fill", "none")
                .attr("stroke", "blue")
                .attr("stroke-width", 1.5)
                .attr("d", d3.line()
                    .x(d => x(d.Date) + x.bandwidth() / 2)
                    .y(d => yRSI(d.RSI))
                );

            // divergence 및 signal-text, highlight도 chartContent 내 관련 그룹에 그리기
            renderDivergences(divergences);

            //ystochastic
            const stochasticLine = d3.line()
                .x(d => x(d.Date) + x.bandwidth() / 2) 
                .y(d => ystochastic(d.stochastic));

            const Y_Stochastic = svg.select(".stochastic")
                .selectAll(".stochasticLine")
                .data([ticker.filter(d => d.stochastic !== null)]);

            Y_Stochastic.enter()
                .append("path")
                .attr("class", "stochasticLine")
                .attr("fill", "none")
                .attr("stroke", "green")
                .merge(Y_Stochastic) // Enter한 데이터 기존 데이터와 병합하여 Update
                .attr("d", stochasticLine);

            Y_Stochastic.exit().remove();

            //bollinger
            const upperLine = d3.line()
                .x(d => x(d.Date) + x.bandwidth() / 2)
                .y(d => y1(d.upperband));

            const lowerLine = d3.line()
                .x(d => x(d.Date) + x.bandwidth() / 2)
                .y(d => y1(d.lowerband));


            // Area 업데이트
            const bandArea = svg.select(".bollinger-area")
                .selectAll("path.area")
                .data([ticker.filter(d => d.upperband !== null && d.lowerband !== null)]);

            bandArea.enter()
                .append("path")
                .attr("class", "area")
                .attr("fill", "blue")
                .attr("opacity", 0.3)
                .merge(bandArea)
                .attr("d", d3.area()
                    .x(d => x(d.Date) + x.bandwidth() / 2)
                    .y0(d => y1(d.upperband))
                    .y1(d => y1(d.lowerband)));

            bandArea.exit().remove();

            // Upper Line 업데이트
            const upperBandLine = svg.select(".bollinger-lines")
                .selectAll("path.upper-line")
                .data([ticker.filter(d => d.upperband !== null)]);

            upperBandLine.enter()
                .append("path")
                .attr("class", "upper-line")
                .attr("fill", "none")
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .merge(upperBandLine)
                .attr("d", upperLine);

            upperBandLine.exit().remove();

            // Lower Line 업데이트
            const lowerBandLine = svg.select(".bollinger-lines")
                .selectAll("path.lower-line")
                .data([ticker.filter(d => d.lowerband !== null)]);

            lowerBandLine.enter()
                .append("path")
                .attr("class", "lower-line")
                .attr("fill", "none")
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .merge(lowerBandLine)
                .attr("d", lowerLine);

            lowerBandLine.exit().remove();

            svg.select(".current-price-line").remove(); // 기존 현재 가격 라인 제거
            svg.select(".current-price-text").remove(); // 기존 현재 가격 텍스트 제거
            const currentPrice = ticker.at(-1).Close;
            const [minValue, maxValue] = y1.domain(); // y1의 도메인 가져오기
            
            if(currentPrice>minValue && currentPrice <maxValue){
                // 현재 가격 라인 업데이트 
                svg.append("line") // 현재 가격 라인 추가
                    .attr("class", "current-price-line")
                    .attr("x1", marginLeft)
                    .attr("x2", width - marginRight)
                    .attr("y1", y1(currentPrice))
                    .attr("y2", y1(currentPrice))
                    .attr("stroke", ticker.at(-1).Open > ticker.at(-1).Close ? "rgb(227,84,97)" : "rgb(94,186,137)")
                    .attr("stroke-width", 1.5)
                    .attr("stroke-dasharray", "4,4");

                svg.append("text") // 현재 가격 텍스트 추가
                    .attr("class", "current-price-text")
                    .attr("x", width-marginRight) // 텍스트는 오른쪽 여백 너머에 표시
                    .attr("y", y1(currentPrice))
                    .attr("dy", "0.35em")
                    .attr("fill", ticker.at(-1).Open > ticker.at(-1).Close ? "rgb(227,84,97)" : "rgb(94,186,137)")
                    .attr("font-size", "11px")
                    .attr("font-family", "Times New Roman") // 폰트 설정
                    .attr("font-weight","bold")
                    .text(`$${currentPrice.toFixed(2)}`);
            }
            buttonTextMA7.text(() => {
                    const round = (num, decimals = 2) => Number(num.toFixed(decimals));
                    return `MA(7):${round(average7[average7.length - 1].average)}`;
             })
             buttonTextMA25.text(() => {
                    const round = (num, decimals = 2) => Number(num.toFixed(decimals));
                    return `MA(25):${round(average25[average25.length - 1].average)}`;
             })
             buttonTextMA99.text(() => {
                    const round = (num, decimals = 2) => Number(num.toFixed(decimals));
                    return `MA(99):${round(average99[average99.length - 1].average)}`;
             })
             buttonTextvolume.text(() => {
                    const round = (num, decimals = 2) => Number(num.toFixed(decimals));
                    return `volume:${round(ticker[ticker.length - 1].Volume)}`;
             })
             buttonTextRSI.text(() => {
                    const round = (num, decimals = 2) => Number(num.toFixed(decimals));
                    return `RSI:${round(ticker_for_indicator[ticker_for_indicator.length - 1].Rsi)}`;
             })
             buttonTextMACD.text(() => {
                    const round = (num, decimals = 2) => Number(num.toFixed(decimals));
                    return `MACD:${round(ticker_for_indicator[ticker_for_indicator.length - 1].macd_line)}`;
             }) .style("fill", "blue");
             buttonTextstochastic.text(() => {
                    const round = (num, decimals = 2) => Number(num.toFixed(decimals));
                    return `Stochastic:${round(ticker_for_indicator[ticker_for_indicator.length - 1].stochastic)}`;
             })
             buttonTextbollingararea.text(() => {
                    const round = (num, decimals = 2) => Number(num.toFixed(decimals));
                    return `BB upper:${round(ticker_for_indicator[ticker_for_indicator.length - 1].upperband)} lower:${round(ticker_for_indicator[ticker_for_indicator.length - 1].lowerband)}`;
             })
        }

        function getMovingAverageData(data, period) {
            return data.map((row, index, total) => {
                const start = Math.max(0, index - period + 1);
                const subset = total.slice(start, index + 1);
                const sum = subset.reduce((acc, d) => acc + d.Close, 0);
                return {
                    Date: row.Date,
                    average: sum / subset.length,
                };
            });
        }
        function calculateMACD() {
            const fastLength = 12;
            const slowLength = 26;
            const signalLength = 9;

            const fastEMA = ema(ticker_for_indicator.map(d => d.Close), fastLength);
            const slowEMA = ema(ticker_for_indicator.map(d => d.Close), slowLength);

            ticker_for_indicator.forEach((d, i) => {
                d.macd_line = fastEMA[i] - slowEMA[i];
            });

            const signalEMA = ema(ticker_for_indicator.map(d => d.macd_line), signalLength);

            ticker_for_indicator.forEach((d, i) => {
                d.signal_line = signalEMA[i];
                d.histogram = d.macd_line - d.signal_line;
            });
        }

        function ema(data, period) {
            const k = 2 / (period + 1);
            const emaArray = [data[0]];
            for (let i = 1; i < data.length; i++) {
                emaArray.push(data[i] * k + emaArray[i - 1] * (1 - k));
            }
            return emaArray;
        }

        function calculateMA(){
            const average7 = ema(ticker.map(d => d.Close), 7);
            const average25 = ema(ticker.map(d => d.Close), 25);
            const average99 = ema(ticker.map(d => d.Close), 99);

            ticker.forEach((d, i) => {
                d.averageLine7 = average7[i];
                d.averageLine25 = average25[i];
                d.averageLine99 = average99[i];
            });
        }

        function RSI(data, period){
            let avgGain = 0, avgLoss = 0;
                const rsiValues = [];

                for (let i = 1; i < data.length; i++) {
                    const change = data[i] - data[i - 1];
                    const gain = Math.max(0, change);
                    const loss = Math.max(0, -change);

                    if (i < period) {
                        avgGain += gain / period;
                        avgLoss += loss / period;
                    } else {
                        avgGain = (avgGain * (period - 1) + gain) / period;
                        avgLoss = (avgLoss * (period - 1) + loss) / period;
                        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                        const rsi = 100 - (100 / (1 + rs));
                        rsiValues.push({ Date: data[i].Date, RSI: rsi });
                    }
                }
                return rsiValues;
        }

        function calculateRSI() {
            const period = 14;
            // ticker 배열에서 Close 값만 추출하여 RSI 계산
            const rsidata = RSI(ticker_for_indicator.map(d => d.Close), period);

            // ticker 배열에 RSI 값을 추가
            ticker_for_indicator.forEach((d, i) => {
                if (i >= period) { // 첫 14일 이후에 RSI 값 할당
                    d.Rsi = rsidata[i - period].RSI;
                } else {
                    d.Rsi = null; // 첫 14일 전까지는 RSI 값 없음
                        }
                    });
                }

        function stochasticrsi(data, period){
            stochastic_rsi =[];
            for (let i = period; i < data.length; i++) {
            const recentRSI = data.slice(i - period, i);

            const min_rsi = Math.min(...recentRSI);  // 최소값
            const max_rsi = Math.max(...recentRSI);  // 최대값

            let stochastic;

            if (max_rsi !== min_rsi) { // NaN 방지 조건
                stochastic = ((data[i-1] - min_rsi) / (max_rsi - min_rsi)) * 100;
            } else {
                stochastic = 50; // 최대값과 최소값이 같을 경우 중간 값으로 설정
            }

            stochastic_rsi.push({ Date: data[i].Date, Stochastic: stochastic });
                }

                return stochastic_rsi;
        }

        function calculatestochastic(){
            const period = 14;
            const rsis = ticker_for_indicator.map(d => d.Rsi || 0); // null-safe 접근
            const stochasticData = stochasticrsi(rsis, period);

             ticker_for_indicator.forEach((d, i) => {
                if (i >= period) { // 첫 14일 이후에 RSI 값 할당
                    d.stochastic = stochasticData[i - period].Stochastic;
                } else {
                    d.stochastic = null; // 첫 14일 전까지는 RSI 값 없음
                        }
             })
        }

        function getStandardDerivation(data, period) {
            const stdDeriv = [];

            for (let i = 0; i< period - 1; i++){
                stdDeriv.push(0);
            }

            for (let i = period - 1; i < data.length; i++){
                const slice = data.slice(i - period + 1, i + 1)
                const mean = slice.reduce((a, b) => a + b, 0) / slice.length;
                const variance = slice.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / slice.length;
                stdDeriv.push(Math.sqrt(variance));
            }
            
            return stdDeriv;
        }


        function calculateBollingerBands(){
            const period = 20;
            const average20 = ema(ticker_for_indicator.map(d => d.Close), period);
            const standardDerivationdata = getStandardDerivation(ticker_for_indicator.map(d => d.Close), period);

            ticker_for_indicator.forEach((d, i) => {
                if (i >= period - 1) { // 첫 20일 이후에 표준편차 값 할당
                    d.avg20 = average20[i];
                    d.standardDerivation = standardDerivationdata[i];
                    d.upperband = d.avg20 + d.standardDerivation;
                    d.lowerband = d.avg20 - d.standardDerivation;
                } else {
                    d.avg20 = null;
                    d.standardDerivation = null; // 첫 20일 전까지는 표준편차 값 없음
                    d.upperband = null;
                    d.lowerband = null;
                        }
             })
        }

        function createButton(x, y, graphClass) {
            const buttonGroup = svg.append("g")
                .attr("class", "button")
                .attr("data-target", graphClass) // 그래프 클래스를 data-target 속성으로 저장
                .attr("width", buttonWidth)
                .attr("height", buttonWidth)
                .attr("transform", `translate(${x},${y})`);

            const buttonRect = buttonGroup.append("rect")
                .attr("class", "button rect")
                .attr("width", buttonWidth/2)
                .attr("height", buttonHeight/2)
                .attr("rx", 10) // Rounded corners
                .attr("fill", "white") // Initial color
                .style("cursor", "pointer");
            
            const eye_icon = buttonGroup.append("path")
                    .attr("class", "eye-icon")
                    .attr("d", "M10 20 Q25 5, 40 20 Q25 35, 10 20 Z")
                    .attr("fill", "none")
                    .attr("stroke", "grey")
                    .attr("stroke-width", 2)
                    .attr("transform", `translate(${buttonWidth/5}, ${-buttonHeight/10})`);

            const eye_icon_circle = buttonGroup.append("circle")
                        .attr("class", "eye-icon circle")
                        .attr("data-target", graphClass)
                        .attr("cx", 25 + (buttonWidth/5))  // X center of the eye (adjust according to eye shape)
                        .attr("cy", 20-buttonHeight/10)  // Y center of the eye (adjust according to eye shape)
                        .attr("r", 7)    // Radius of the pupil
                        .attr("fill", "grey");  // Color of the pupil
                
            // 클릭 이벤트: 해당 그래프를 토글
            d3.selectAll(".eye-icon")
            .on("click", function() {
                const targetClass = d3.select(this).attr("data-target");

                // RSI 버튼 클릭 시 RSI, highlight, divergence 모두 토글하는 예시가 있었다면 
                // 여기서는 bollinger-area 클릭 시 bollinger-area와 bollinger-lines 둘 다 토글
                if (targetClass === "bollinger-area") {
                    const area = svg.select(".bollinger-area");
                    const lines = svg.select(".bollinger-lines");

                    // 하나라도 보이는 상태라면 모두 숨기고, 하나라도 보이지 않는 상태라면 모두 보이기
                    const isVisible = area.style("display") !== "none" || lines.style("display") !== "none";
                    area.style("display", isVisible ? "none" : "block");
                    lines.style("display", isVisible ? "none" : "block");
                    
                }
                else if (targetClass === "rsi") {
                    const rsiGroup = svg.select(".RSI");
                    const highlightGroup = svg.select(".highlight");
                    const divergenceGroup = svg.select(".divergence");
                    
                    // 하나라도 display가 none이 아니면(즉, 보이는 상태라면)
                    const isVisible = rsiGroup.style("display") !== "none" 
                                    || highlightGroup.style("display") !== "none" 
                                    || divergenceGroup.style("display") !== "none";

                    // 모두 동일하게 토글
                    rsiGroup.style("display", isVisible ? "none" : "block");
                    highlightGroup.style("display", isVisible ? "none" : "block");
                    divergenceGroup.style("display", isVisible ? "none" : "block");
                }
                else {
                    // 나머지 버튼은 기존처럼 targetClass 해당 그래프만 토글
                    const graph = svg.select(`.${targetClass}`);
                    const isVisible = graph.style("display") !== "none";
                    graph.style("display", isVisible ? "none" : "block");
        }
    });

            return buttonGroup;
        }
        function calculateRSI_2(data, period) {
            let gains = 0, losses = 0;
            const rsiData_2 = [];

            for (let i = 1; i < data.length; i++) {
                const change = data[i].Close - data[i - 1].Close;
                if (change > 0) gains += change;
                else losses -= change;

                if (i >= period) {
                    const avgGain = gains / period;
                    const avgLoss = losses / period;
                    const rs = avgGain / avgLoss;
                    const rsi = 100 - (100 / (1 + rs));

                    rsiData_2.push({ Date: data[i].Date, RSI: rsi });

                    const prevChange = data[i - period + 1].Close - data[i - period].Close;
                    if (prevChange > 0) gains -= prevChange;
                    else losses += prevChange;
                }
            }

            return rsiData_2;
        }

        function findPivotLows(data, lookback) {
            const pivotLows = [];

            for (let i = lookback; i < data.length - lookback; i++) {
                const isPivotLow = data.slice(i - lookback, i + lookback + 1)
                    .every((d, index) => index === lookback || data[i].RSI < d.RSI);

                if (isPivotLow) {
                    pivotLows.push({ Date: data[i].Date, RSI: data[i].RSI });
                }
            }

            return pivotLows;
        }

        function calculateDivergences(data, pivotLows) {
            const divergences = [];

            for (let i = 1; i < pivotLows.length; i++) {
                const prevPivot = pivotLows[i - 1];
                const currPivot = pivotLows[i];

                const isBullishDivergence =
                    currPivot.RSI > prevPivot.RSI &&
                    data.find(d => d.Date.getTime() === currPivot.Date.getTime()).Close <
                    data.find(d => d.Date.getTime() === prevPivot.Date.getTime()).Close;

                if (isBullishDivergence) {
                    divergences.push({ prev: prevPivot, curr: currPivot });
                }
            }

            return divergences;
        }
        function renderDivergences(divergences) {
    const chartContent = svg.select(".chart-content");

    // 이전에 그렸던 highlight, divergence, signal-text 요소 제거
    chartContent.select(".highlight").selectAll("*").remove();
    chartContent.select(".divergence").selectAll("*").remove();
    chartContent.select(".signal-text").selectAll("*").remove();

    divergences.forEach(({ prev, curr }) => {
        // highlight 그룹에 rect 추가
        chartContent.select(".highlight").append("rect")
            .attr("x", x(prev.Date))
            .attr("y", yRSI(100))
            .attr("width", x(curr.Date) - x(prev.Date) + x.bandwidth())
            .attr("height", yRSI(0) - yRSI(100));

        // signal-text 그룹에 Buy 신호 표시
        chartContent.select(".signal-text").append("text")
            .attr("x", x(curr.Date) + x.bandwidth() / 2)
            .attr("y", y1(ticker.find(d => d.Date.getTime() === curr.Date.getTime()).Low) + 25)
            .attr("font-size", "30px")
            .attr("fill", "green")
            .attr("text-anchor", "middle")
            .text("▲");

        chartContent.select(".signal-text").append("text")
            .attr("x", x(curr.Date) + x.bandwidth() / 2)
            .attr("y", y1(ticker.find(d => d.Date.getTime() === curr.Date.getTime()).Low) + 45)
            .attr("font-size", "30px")
            .attr("fill", "green")
            .attr("text-anchor", "middle")
            .text("Long");

        // Exit 신호도 동일한 signal-text 그룹 내에 추가
        const sellSignal = calculateSellSignal(curr.Date);
        if (sellSignal) {
            chartContent.select(".signal-text").append("text")
                .attr("x", x(sellSignal.Date) + x.bandwidth() / 2)
                .attr("y", y1(ticker.find(d => d.Date.getTime() === sellSignal.Date.getTime()).High) - 25)
                .attr("font-size", "30px")
                .attr("fill", "red")
                .attr("text-anchor", "middle")
                .text("▼");
            
            chartContent.select(".signal-text").append("text")
                .attr("x", x(sellSignal.Date) + x.bandwidth() / 2)
                .attr("y", y1(ticker.find(d => d.Date.getTime() === sellSignal.Date.getTime()).High) - 50)
                .attr("font-size", "30px")
                .attr("fill", "red")
                .attr("text-anchor", "middle")
                .text("Exit");
        }
    });

    // divergence 그룹에 "Bull" 텍스트 추가
    chartContent.select(".divergence")
        .selectAll("text")
        .data(divergences)
        .enter()
        .append("text")
        .attr("x", d => x(d.curr.Date) + x.bandwidth() / 2 + 18)
        .attr("y", d => yRSI(85))
        .attr("fill", "green")
        .attr("font-size", "22px")
        .attr("text-anchor", "middle")
        .text("Bull");
}
        function calculateSellSignal(buyDate) {
            const buyPrice = ticker.find(d => d.Date.getTime() === buyDate.getTime()).Close;
            for (let i = 0; i < ticker.length; i++) {
                if (ticker[i].Date.getTime() > buyDate.getTime()) {
                    const currentPrice = ticker[i].Close;
                    const rsi = calculateRSI_2(ticker.slice(0, i + 1), 14).at(-1);
                    const priceDrop = (buyPrice - currentPrice) / buyPrice * 100;

                    if ((rsi && rsi.RSI >= 70) || priceDrop >= 3) {
                        return { Date: ticker[i].Date, RSI: rsi?.RSI || null };
                    }
                }
            }
            return null;
        }

        // WebSocket을 통해 실시간 데이터 추가
        function startWebSocket() {
            const socket = new WebSocket("wss://stream.binance.com:9443/ws/btcusdt@kline_15m");
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                const kline = data.k;

                const newCandle = {
                    Date: new Date(kline.t),
                    Open: +kline.o,
                    High: +kline.h,
                    Low: +kline.l,
                    Close: +kline.c,
                    Volume: +kline.v
                };

                 // 진행 중인 캔들스틱 업데이트
                 if (ticker.length > 0 && ticker.at(-1).Date.getTime() === newCandle.Date.getTime()) {
                        const lastCandle = ticker.at(-1);

                        lastCandle.High = Math.max(lastCandle.High, newCandle.High);
                        lastCandle.Low = Math.min(lastCandle.Low, newCandle.Low);
                        lastCandle.Close = newCandle.Close;
                        lastCandle.Volume = newCandle.Volume; //last candle만 바꿔도 ticker가 수정됨

                        
                    } else {
                        // 새로운 캔들스틱 추가 (진행 중)
                        ticker.push(newCandle);
                        ticker_for_indicator.push(newCandle);
                        if(ticker.length>100)
                            ticker.shift();
                    }

                // 차트 업데이트
                calculateMACD();
                calculateMA();
                calculateRSI();
                calculatestochastic();
                calculateBollingerBands();
                
                updateChart();
            };
        }
        const zoom = d3.zoom()
                .scaleExtent([1, 20])
                .translateExtent([[0, 0], [width,height]]) //[marginLeft, 0], [width - marginRight, height]
                .on("zoom", (event) => {
                    const transform = event.transform;
                    x.range([marginLeft, width - marginRight].map(d => transform.applyX(d)));
                    xBar.range([marginLeft, width - marginRight].map(d => transform.applyX(d)));    
                    
                    // padding 값을 줌의 scale에 비례해 조정
                    const zoomLevel = Math.floor(transform.k); // 줌 레벨
                    //console.log("Zoom Level:", zoomLevel);
                    const paddingValue = Math.max(0.3, Math.min(0.5, 0.5 - (zoomLevel - 1) * 0.1));   // 줌 레벨에 따라 padding 값을 계산
                    x.padding(paddingValue); // scaleBand의 padding 값 업데이트

                    updateChart(zoomLevel);
                });
            
            svg.call(zoom);
        fetchInitialData();
    </script>
</body>
</html>